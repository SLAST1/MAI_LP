# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Пивницкий Д.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в языке Prolog представляется в виде двочного дерева, в листьях которого находится либо эл-т, либо пустой список. Элементами списка являются произвольные термы. То есть это рекурсивная структура, которая либо пуста, либо состоит из головы и хвоста, где хвост тоже список.
```
       •
      / \
    [a]  •
        / \
      [b]  •
          / \
        [c] [ ]
```
Рассмотрев такое представление списка, делаем вывод, что оно сильно отличается от представления в императивных языках. В языке Prolog мы обрабатываем элементы списка только рекурсивно, разделяя список на голову и хвост. В императивных языках мы можем обратиться к любому эл-ту списка, используя, например, итераторы. Кроме того, список в имп. языках содержит эл-ты одного типа, в Prolog же списки содержат любые эл-ты. На мой взгляд, списки в Prolog ближе всего к массивам, т.к являются базовыми контейнерами для хранения эл-тов.

## Задание 1.0: Реализация стандартных предикатов обработки списков
Были реализованы следующие стандартные предикаты:
1) Предикат длины списка
```prolog
% Формат ввода: (список, длина)
mylength([], 0) . 
mylength([_|T], N) :- mylength(T, N1), N is N1 + 1.
```
2) Предикат принадлежности элемента списку
```prolog
% Формат ввода: (элемент, список)
mymember(X,[X|L]).
mymember(X,[L|T]) :- mymember(X,T).
```
3) Предикат конкатенации списков
```prolog
% Формат ввода: (список1, список2, список1+2)
myappend([],L,L).
myappend([H|T], L, [H|R]) :- myappend(T,L,R).
```
4) Предикат удаления элементов из списка
```prolog
% Формат ввода: (элемент, список, список без элемента)
myremove(E,[E|S],S).
myremove(E,[E1|S],[E1|X]) :- myremove(E,S,X).
```
5) Предикат перестановки элементов списка
```prolog
% Формат ввода: (список, перестановка)
mypermute([],[]).
mypermute(S,[L|Y]) :-
    myremove(L,S,X),
    mypermute(X,Y).
```
6) Предикат подсписка списка
```prolog
% Формат ввода: (подсписок, список)
mysublist(X,Y) :-
    myappend(S,L,M),
    myappend(X,S,L).
```

## Задание 1.1: Предикат обработки списка
Получение последнего элемента X в списке L.
- с использованием встроенных предикатов
`getlast(L, X)` 
- без использования встроенных предикатов
`mygetlast(L, X)`

Примеры использования:
```prolog
?- getlast([1, 2, 4], X).
X = 4 ;
false.
      
?- mygetlast([1, 2, 4], X).
X = 4 ;
false.
```

Реализация:
- с использованием встроенных предикатов. Создается на основе встроенного предиката `append`, который конкатенирует какой-то список `_` и список, состоящий из последнего эл-та `[X]` в список `L`
```prolog
getlast(L, X) :- append(_,[X],L).
```
- без использования встроенных предикатов. Задается рекурсивно. Последний эл-т одноэлементного списка - сам эл-т. Если в списке > 1 эл-та, то отделяем хвост `L` и рассматриваем его как одноэлементный список.
```prolog
mygetlast([X], X).
mygetlast([_|L], X) :- mygetlast(L, X).
```

## Задание 1.2: Предикат обработки числового списка

Вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей).
```prolog
scalarproduct(V1, V2, P)
```

Примеры использования:
```prolog
?- scalarproduct([3, 4],[5, 6],X).
X = 39.

?- scalarproduct([3, 4, 4],[5, 6],X).
false.

?- scalarproduct([4, 5, 7],[5, 6, 1],X).
X = 57.
```

Реализация:
Задается рекурсивно. Скалярное произведение двух пустых списков равно нулю. Если в списке > 1 эл-та, то отделяем хвосты `XT`  и `YT` И находим их произведение, пока не дойдем до голов `X` и `Y` и прибавив их произведение к суммме произведений `P` получим скалярное произведение `S`.
```prolog
scalarproduct([],[],0).
scalarproduct([X|XT],[Y|YT],S) :-
    !,
    scalarproduct(XT, YT, P), 
    S is (P + X * Y).
```

## Задание 1.3: Пример совместного использования предикатов

Предикат для нахождение длины списка до и после удаления последнего элемента и вывод последнего элемента
```prolog
coop(L, X1, P, X2) % Формат ввода: (список, длина до удаления, последний эл-т, длина после удаления)
```

Примеры использования:
```prolog
?- coop([1,2,4],X1,P,X2).
X1 = 3, % длина до удаления
P = 4, % последний эл-т
X2 = 2 ; % длина после удаления
```

Реализация:
```prolog
coop(L, X1, P, X2):-
    mylength(L,X1),
    mygetlast(L, P),
    myremove(P, L, L1),
    mylength(L1, X2).
```
Для реализации данного преликата были использованы предикаты:
- `mylength(T, N1) % Предикат длины списка`
- `mygetlast(L, X) % Получение последнего элемента`
- `myremove(E,S,X) % Предикат удаления элементов из списка`

## Задание 2: Реляционное представление данных

Реляционное представление достаточно удобно для работы с информацией, которая представляетс в виде таблиц. Недостатком являестя то, что порой нам приходиться проходить целый список за линейное время для вычленения конкретной информации.

Реляционное представление, доставшееся мне, очень удобно объединяет информацию по группам и предметам, поэтому нам достаточно просто находить что-то по группе или по предмету. В то же время, когда дело доходит до оценок, то нам достаточно часто приходиться обращаться к `member` и `findall`, что повышает сложность нашего алгоритма.

1. Предикат получения таблицы групп и среднего балла по каждой из групп
```prolog
tablesredn()
```
Вспомогательные предикаты:
- `mysum(Y, N)`;
- `sredn(L, R)`;
- `grades(Student, G)`;
- `allgradeaver(Student, Aver)`;
- `allgradeaveringroup(Group, GrAver)`

Примеры использования:
```prolog
?- tablesredn().
| Группа №102 | Cредний бал: 3.9444444444444446
| Группа №101 | Cредний бал: 3.9666666666666672
| Группа №104 | Cредний бал: 3.861111111111111
| Группа №103 | Cредний бал: 4.145833333333334
false.
```

Реализация:
Задан рекурсивно. Сумма эл-в пустого списка равна нулю. Далле отделяется хвост и сумма увеличивается на кол-во эл-в в хвосте, т.е на единицу.
```prolog
% Предикат для нахождения суммы
% Формат ввода: (список, сумма)
mysum([], 0).
mysum([X|Y], S) :-
    mysum(Y, N),
    S is N + X.
```
Находит длину списка встроенным предикатом `length`, высчитывает сумму элементов списка с помощью описанного выше `mysum` и находит ср. значение по формуле ср. арифметического.
```prolog
% Предикат для нахождения среднего значения
% Формат ввода: (список, среднее ар.)
sredn(L, R) :-
    length(L, Len),
    mysum(L, Sum),
    R is Sum / Len.
``` 
Проходит по списку всех фактов оценок `grade` по всевозможным предметам и находит унификацию студента `'Student'` и выводит для него оценку `G`. Использован встроенный предикат `member`.
```prolog
% Предикат для нахождения всех оценок студента 'Student'
% Формат ввода: (студент, оценка) 
grades(Student, G) :-
    subject(_, X),
    member(grade(Student, G), X).
```
Собирает при помощи `findall` всевозможные списки `List` оценок и находит среднее при помощи описанной выше `sredn`.
```prolog
% Предикат для нахождения среднего ар. всех оценок студента 'Student'
% Формат ввода: (студент, ср. ар)
allgradeaver(Student, Aver) :-
    findall(G, grades(Student, G), List),
    sredn(List, Aver).
```
Проверяет является ли студент `member` для `StudList`, который в свою очередь сформирован из предиката `group`. Далее при помощи `allgradeaver` нахолит ср. ар. оценок этого студента.
```prolog
% Предикат для нахождения среднего балла студента 'Student' в группе
% Формат ввода: (студент, ср. б. в группе)
allgradeaveringroup(Group, GrAver) :-
    group(Group, StudList),
    member(Stud, StudList),
    allgradeaver(Stud, GrAver).
```
Предикат, который позволяет вывести сразу нужные данные в виде таблицы.
```prolog
% Предикат для вывода таблицы групп и среднего балла по каждой из групп
tablesredn() :-
    group(Group,_),
    findall(GrAver, allgradeaveringroup(Group, GrAver), X),
    sredn(X, Ans),
    write('| Группа №'), write(Group), write(' | Cредний бал: '), write(Ans), write('\n'), fail.
```

2. Предикат для нахождения списка студентов, не сдавших экзамен 'Exam' (grade = 2)
```prolog
failstudlist(Exam, List) % Формат ввода: (экзамен, список студентов)
```

Вспомогательный предикат:
- `failstud(Exam, Surname)`

Примеры использования:
```prolog
?- failstudlist('Логическое программирование', List).
List = ['Петровский', 'Сидоров', 'Джаво'].

?- failstudlist('Психология', List).
List = ['Безумников', 'Круглосчиталкин'].
```

Реализация:
Для данного экзамена находит список студентов с оценками `Students`, далее при помощи `member` проверяет имеет ли данный студент `2` или нет.
```prolog
% Предикат для нахождения имен студентов, не сдавших экзамен 'Exam'
% Формат ввода: (экзамен, фамилия студента) 
failstud(Exam, Surname) :-
    subject(Exam, Students),
    member(grade(Surname, 2), Students).
```
Собирает всех студентов, получивших `2` при помощи `findall` в список `List`
```prolog
% Предикат для нахождения списка студентов, не сдавших экзамен 'Exam'
% Формат ввода: (экзамен, список студентов)
failstudlist(Exam, List) :-
    subject(Exam,_),
    findall(Surname, failstud(Exam, Surname), List).
```

3. Предикат для нахождения кол-ва несдавших студентов в группе
```prolog
numberfailstudingroup(Group, Num) % Формат ввода: (группа, число несдавших)
```

Вспомогательный предикат:
- `failstudingroup(Group,Surname)`

Примеры использования:
```prolog
?- numberfailstudingroup(101, Num).
Num = 3.

?- numberfailstudingroup(102, Num).
Num = 3.

?- numberfailstudingroup(103, Num).
Num = 2.

?- numberfailstudingroup(104, Num).
Num = 2.
```

Реализация:
Выводит списки оценок по всевозможным предметам, далее при помощи двух `member` проверяет принадлежность группе и наличие `2`.Возвращает фамилии студентов.
```prolog
% Предикат для нахождения несдавших студентов в группе
% Формат ввода: (группа, фамилии несдавших студентов)
failstudingroup(Group,Surname) :-
    subject(_,GradesList),
    group(Group,StudsList),
    member(Surname,StudsList),
    member(grade(Surname,2),GradesList).
```
Находит всевозможные фамилии несдавших студентов и собирает их в список `List` при помощи `findall`, далее при помощи встроенного предиката `length` находит кол-во несдавших студентов.
```prolog
% Предикат для нахождения кол-ва несдавших студентов в группе
% Формат ввода: (группа, число несдавших)
numberfailstudingroup(Group, Num) :-
    findall(Surname, failstudingroup(Group, Surname), List),
    length(List, Num).
```

## Выводы

Приступая к изучению какой-то предметной области, важно в самом начале показать основные принципы работы с этой предметной областью. В нашем случае для Логического программирования этим показательным примером стали списки.  Выполняя данную лабораторную работу, я закрепил в своей голове такие основные принципы:
- пытаться думать о задаче, как о ряде вложенных более простых задач,
- рекурсия довольно хорошо справляется с решением ряда задач, особенно математического характера,
- нужно быть поаккуратней с именованем термов.

Надеюсь дальнейшие лабораторные работы пополнят запас этих принципов и расширят мои знания в Логическом программировании. 