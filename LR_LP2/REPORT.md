# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Пивницкий Д.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения логических задач методом перебора применяются два основных подхода:
1) Метод порождения и проверок. Основная идея данного метода заключается в том, что есть две отдельные структуры. Первая генерирует множество исходных данных, которые будут далее обрабатываться. Вторая проверяет данные на соответствие условию задачи. В случае неудачи цикл генерации-проверки повторяется вплоть до получения удачного решения, соответствующего условию задачи; 

2) Метод ветвей и границ. Главным достоинством данного метода является отсечение заведомо неверных решений на ранних этапах, что значительно снижает кол-во переборов. В данном методе генерация происходит поэтапно, а не одновременно, в остальном этот метод довольно схож с первым.

Prolog оказывается удобным для написания решателей таких логических задач, так как в нем есть механизм отката (backtracking), который позволяет выходить из ветки с неудачным решением и продолжать поиск вплоть до нахождения верного решения. Также большим плюсом является то, что нам лишь нужно написать условие задачи в виде всех основных фактов, без каких-либо умозаключений.

## Задание

  19. Кондратьев, Давыдов и Федоров живут на нашей улице. Один из них столяр, другой  маляр, третий  водопроводчик. Недавно маляр хотел попросить своего знакомого столяра сделать кое-что для своей квартиры, но ему сказали, что столяр работает в доме водопроводчика. Известно также, что Федоров никогда не слышал о Давыдове. Кто чем занимается?

## Принцип решения

1. Запишем все основные факты, вытекающие из условия, в виде Prolog предикатов:
```prolog
% Факт: маляр знаком со столяром
data(_,znakomi,[malyar,stolyar],true).
data(_,znakomi,[stolyar,malyar],true).

% Факт: столяр знаком с водопроводчиком
data(_,znakomi,[stolyar,vodoprovodchik],true).
data(_,znakomi,[vodoprovodchik, stolyar],true).

% Факт: маляр слышал про водопроводчика
data(_,znakomi,[malyar,vodoprovodchik],true).

% Факт: Федоров не слышал о Давыдове
data([_,D,F],znakomi,[F,D],false).
```
2. Напишем предикат, проверяющий наличие противоречия в фактах. Для этого также реализуем вспомогательный предикат логического нет `logicalnot`:
```prolog
% Предикаты логического нет
logicalnot(true,false).
logicalnot(false,true).

% Предикат наличия противоречия
contradiction(V):- 
    data(V,F,A,TF), 
    logicalnot(TF,FT), 
    data(V,F,A,FT).
```
3. И при помощи последнего предиката будем сопостовлять список фамилиий `[K,D,F]` (`K` - Кондратьев, `D` - Давыдов, `F` - Федоров) со списком профессий `[stolyar,malyar,vodoprovodchik]`, проверять отсутствие противоречий будем при помощи отрицания предиката `contradiction`. Кроме того нам нужно будет воспользоваться стандартным предикатом для обработки списков `permute`, котрый не является встроенным в моей системе программирования, поэтому также напишем его реализацию:
```prolog
% Предикат удаления элементов из списка
remove(E,[E|S],S).
remove(E,[E1|S],[E1|X]) :- remove(E,S,X).

% Предикат перестановки элементов списка
permute([],[]).
permute(L,[X|T]):-remove(X,L,R), permute(R,T).

% Предикат решения
solve(K,D,F) :- 
    permute([K,D,F],[stolyar,malyar,vodoprovodchik]), 
    not(contradiction([K,D,F])).
```
4. В качестве дополнения напишем предикат `answer`, который будет выводить решение предиката `solve` в удобном для восприятия виде:
```prolog
% Предикат вывода ответа
answer():- 
    solve(K,D,F),
    write('Kondratev - '), write(K), nl,
    write('Davidov - '), write(D), nl,
    write('Fedorov - '), write(F),
    fail.
```
Результат выполнения программы:
```prolog
?- answer().
Kondratev - stolyar
Davidov - malyar   
Fedorov - vodoprovodchik
false.
```
Проверим наше полученное решение на достоверность:

Начнем решение с анализа факта: «Федоров никогда не слышал о Давыдове». Сопоставляя его с другими данными, можно сделать вывод, что Федоров — не маляр, так как маляр
знает столяра и слышал о водопроводчике. Столяр, в свою очередь, знает маляра и знает водопроводчика, так как работает у него в доме. Следовательно, Федоров и не столяр. Остается единственно возможный вариант: Федоров — водопроводчик. А так как водопроводчик, несомненно, знает столяра, работающего у него в доме, то Давыдовым может быть только маляр. Следовательно, Кондратьев — столяр.

Наше решение сопало с обычным решением данной задачи.

Программа является безопасной, т.к в ней нет зацикливаний и выдается одно единственное решение.

На последок поговорим о сложности данной программы. Все используемые предикаты обладают линейной сложностью, но из-за использования предиката `permute`, который имеет факториальную сложность, и наш предикат `solve`, его использующий, асимптотически стремится к `O(N!)`.

## Выводы

Для меня стало открытием, что те самые логические задачи, которые многие из нас решали в разные периоды своей жизни, оказывается можно решать посредством такого языка програмиирования как Prolog. В данном случае легко увидеть как при помощи умелого использования возможностей Prolog-а, а именно его невероятного умения перебирать решения, можно так быстро решать подобные задачи, особенно с большим количеством условий и нюансов, которые человек, в свою очередь, будет сравнивать и анализировать, а на этот процесс порой уходит достаточно много времени.

Если говорить о навыках, которые  я получил по мере выполнения данной лабораторной работы, то это, конечно же, приложение Prolog-а к решению логических задач. Также мною был закреплен материал прошлой лабораторной работы, а именно написание предикатов, использующих списки.
